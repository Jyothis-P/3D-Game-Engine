<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <title>Document</title>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="dash">
        <button id="add-box">Cube</button>
        <button id="add-ball">Sphere</button>
        <button id="left">Left</button>
        <button id="right">Right</button>
        <button id="up">Up</button>
        <button id="down">Down</button>
        <button id="back">Back</button>
        <button id="front">Front</button>
        <br>
        Camera
        <button id="camera-right">+</button>
        <button id="camera-left">-</button>
        <br>
        Entities
        <select name="Entites" id="entities-select">
            <option value="">---</option>
        </select>
    </div>
</body>
<script>

    window.ECS = {
        Components: {},
        systems: {},
        entities: [],

        Input: {},
        world: {},
        scene: {},
        game: {}

    }

    ECS.$canvas = document.getElementById('canvas');

</script>
<script src="scripts/three.min.js"></script>
<script src="scripts/TrackballControls.js"></script>
<script src="scripts/cannon.min.js"></script>
<script>

    const canvas = document.querySelector('#canvas')
    const renderer = new THREE.WebGLRenderer({canvas});

    let scene = new THREE.Scene();
    let world = new CANNON.World();

    // Set up the physical world.
    world.gravity.set(0, -9.8, 0);
    world.broadphase = new CANNON.NaiveBroadphase();
    world.solver.iterations = 10;


    // Camera
    function makeCamera(fov = 40) {
        const aspect = 2,
            near = 0.1,
            far = 1000
        return new THREE.PerspectiveCamera(fov, aspect, near, far)
    }

    const addCubeBtn = document.getElementById('add-box');
    const addSphereBtn = document.getElementById('add-ball');


    // Simple Camera
    const camera = makeCamera()
    let trackball = new THREE.TrackballControls(camera)
    camera.position.set(8, 4, 10).multiplyScalar(3)
    camera.lookAt(0, 0, 0)


    // Light
    {
        const color = 0xFFFFFF,
            intensity = 1
        const light = new THREE.DirectionalLight(color, intensity)
        scene.add(light)
        light.castShadow = true
        light.shadow.mapSize.width = 2048
        light.shadow.mapSize.height = 2048

        const d = 50
        light.shadow.camera.left = -d
        light.shadow.camera.right = d
        light.shadow.camera.top = d
        light.shadow.camera.bottom = -d
        light.shadow.camera.near = 1
        light.shadow.camera.far = 50
        light.shadow.bias = 0.001
    }

    {
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(1, 2, 4);
        scene.add(light);
    }

    // Responsive display
    function resizeRenderer(renderer) {
        const canvas = renderer.domElement
        const {clientWidth, clientHeight} = canvas

        const pixelRatio = window.devicePixelRatio

        const width = clientWidth * pixelRatio | 0
        const height = clientHeight * pixelRatio | 0

        const needResize = canvas.width !== width || canvas.height !== height
        if (needResize) {
            renderer.setSize(width, height, false)
        }
        return needResize
    }

    function getGeometryShape(params) {
        let geometry, shape;
        let width = ('width' in params) ? params.width : 5;
        let height = ('height' in params) ? params.height : 5;
        let depth = ('depth' in params) ? params.depth : 5;
        let radius = ('radius' in params) ? params.radius : 2.5;
        switch (params.type) {
            case 'box':
                geometry = new THREE.BoxGeometry(width, height, depth);
                shape = new CANNON.Box(new CANNON.Vec3(width / 2, height / 2, depth / 2));
                break;
            case 'sphere':
                geometry = new THREE.SphereGeometry(radius, 20, 20);
                shape = new CANNON.Sphere(radius);
                break;
            case 'cylinder':
                geometry = new THREE.CylinderGeometry(radius, radius, height, 20);
                shape = new CANNON.Cylinder(radius, radius, height, 20);
                break;
            default:
                throw "Visual type not recognized: " + params.type;
        }
        return {geometry, shape}
    }

    function getObject(params) {
        params = params || {};
        
        params.type = ('type' in params) ? params.type : 'box';
        let mass = ('mass' in params) ? params.mass : 1;
        let color = ('color' in params) ? params.color : 0xff88aa;
        let position = params.position || {x: 0, y: 10, z: 0};
        let material = new THREE.MeshPhongMaterial({color: color});

        let {geometry, shape} = getGeometryShape(params);

        const body = new CANNON.Body({
            mass: mass,
            shape: shape,
            position: new CANNON.Vec3(position.x, position.y, position.z),
            material: new CANNON.Material({friction: 0.1})
        });

        let mesh = new THREE.Mesh(geometry, material);
        mesh.position.x = position.x;
        mesh.position.y = position.y;
        mesh.position.z = position.z;
        mesh.cannon_rigid_body = body;
        
        world.add(body);
        scene.add(mesh);
        return mesh;
    }
    
    window.ground = getObject({
        width: 50,
        height: .1,
        depth: 50,
        mass: 0,
        color: 0xCC8866
    })


    // Dash listeners
    addCubeBtn.addEventListener('click', (event) => {
        window.cube = getObject({
            type: 'box',
            position: {x: 0, y: 20, z: 0}
        });
    })
    addSphereBtn.addEventListener('click', (event) => {
        window.cube = getObject({
            type: 'sphere',
            position: {x: 0, y: 20, z: 0}
        });
    })

    function render(time) {
        time *= 0.001

        if (resizeRenderer(renderer)) {
            const canvas = renderer.domElement
            camera.aspect = canvas.clientWidth / canvas.clientHeight
            camera.updateProjectionMatrix()
        }

        world.step(1 / 60);

        for (let mesh of scene.children) {
            if (!mesh.cannon_rigid_body) continue

            mesh.position.copy(mesh.cannon_rigid_body.position)
            mesh.quaternion.copy(mesh.cannon_rigid_body.quaternion)
        }

        trackball.update();
        renderer.render(scene, camera)

        requestAnimationFrame(render)
    }

    requestAnimationFrame(render)

</script>
</html>